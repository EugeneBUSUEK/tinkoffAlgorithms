## Task Numeration
### 1th week
* [task1:](https://codeforces.com/problemset/problem/339/A)
* [task2:](https://codeforces.com/problemset/problem/160/A)
* [task3:](https://codeforces.com/problemset/problem/405/A)
* [task4:](https://codeforces.com/problemset/problem/141/A)
* [task5:](https://codeforces.com/problemset/problem/1399/A)
* [task6:](https://codeforces.com/problemset/problem/723/A)
### 2th week
* [task7:](https://codeforces.com/problemset/problem/1251/A)
* [task8:](https://codeforces.com/problemset/problem/381/A)
* [task9:](https://codeforces.com/problemset/problem/1225/B2)
* [task10:](https://codeforces.com/problemset/problem/251/A)
* [task11:](https://codeforces.com/problemset/problem/279/B)
* [task12:](https://codeforces.com/problemset/problem/580/B)
### 3th and 4th week
* [task13:](https://codeforces.com/problemset/problem/1288/A)
* [task14:](https://codeforces.com/problemset/problem/492/B)
* [task15:](https://codeforces.com/problemset/problem/1352/C)
* [task16:](https://codeforces.com/problemset/problem/1328/B)
* [task17:](https://codeforces.com/problemset/problem/1217/A)
* [task18:](https://codeforces.com/problemset/problem/1183/C)
### 5th week
* [task19:](https://codeforces.com/problemset/problem/478/B)
* [task20:](https://codeforces.com/problemset/problem/1294/C)
* [task21:](https://codeforces.com/problemset/problem/545/D)
* [task22:](https://codeforces.com/problemset/problem/508/B)
* [task23:](https://codeforces.com/problemset/problem/519/C)
* [task24:](https://codeforces.com/problemset/problem/1037/C)
### 6th and 7th week
* [task25:](https://codeforces.com/problemset/problem/368/B)
* [task26:](https://codeforces.com/problemset/problem/363/B)
* [task27:](https://codeforces.com/problemset/problem/651/A)
* [task28:](https://codeforces.com/problemset/problem/327/A)
* [task29:](https://codeforces.com/problemset/problem/1323/A)
* [task30:](https://codeforces.com/problemset/problem/753/A)
### 8th week
* [task31:](https://codeforces.com/problemset/problem/115/A)
* [task32:](https://codeforces.com/problemset/problem/500/A)
* [task33:](https://codeforces.com/problemset/problem/1255/B)
* [task34:](https://codeforces.com/problemset/problem/1433/D)
* [task35:](https://codeforces.com/problemset/problem/1490/D)
* [task36:](https://codeforces.com/problemset/problem/277/A)
### 11th and 12th week
* ...
* 
### Task1
Использовал сортировку подсчетом т к всего 3 вида монеток
### Task2
Использовал сортировку выбором
### Task3
Пузырьковая сортировка просто так для разнообразия
### Task4
Сортировка слиянием для разнообразия
### Task5
Быстрая сортировка для разнообразия
### Task6
Пузырьковая сортировка просто так
### Task13
Была попытка к использованию тернарного поиска т к задача на нахождение минимума а массиве составленного из
отсотированного поубыванию мааасива + отсортированного по возрастанию массива. Решение: проходимся обыкновенным 
бинпоискои с двух сторон к минимуму (условно к середине массива)
### Task14
Отсортировали массив координат и нашли наибольшее расстояние между соседними координатами в том числе и началом и 
концом улицы
### Task15
Использовать бинарный поиск для нахождение нужного числа. Идея: на каждой итерации проверяем что число(m) удовлетворяет 
условию следующим образом. Под какаим номером находится это число вычисляем так: m = m - (m / n) где m - наше число 
n - число которому оно не должно быть кратно. Эта формула позволяет убрать количество кратных n чисел. Далее сравниваем 
номера. В конце цикла перед возвращение ответа нужно убедиться что найденое число не кратное число. Если это так то мы 
просто из результата вычитаем 1 т к знаем что под таким же номером стоит число перед ним иначе просто отдаем результат.
### Task16
Использовать бинарный поиск для того чтобы найти позицию первой в строке буквы 'b' такую чтобы точно быть уверенным что
в искомой строке она находиться именно там. Для того чтобы определить диапазон номеров строчек для такой конфигурации 
воспользовался формулой нахождения суммы n-ых членов арифм прогрессии. Далее из максималного значения в этом диапазоне 
вычитаем номер искомой строки(k) тем самым определяем на сколько символов вторая 'b' смещена от первой. Зная индексы 
двух букв сформируем строку-ответ.
### Task17
Воспользовался бинарным поиском для нахождения наибольшего количесва очков которые можно вложить в интеллект так 
чтобы остальные значения показателей персонажа удовлетворяли условиям задачи. Это чило на 1 меньше искомого ответа.
Нужно учитывать что могут быть случаи когда при любом расскладе не удасться выполнить условия тогда это нужно обработать
и вернуть 0.
### Task18
Воспользовался бинарным поиском для нахождения максимального номера "простого" хода при котором выполняются условия 
задачи.
### Task19
Чтобы найти максимум кидаем всех участников так: во все кроме одной команды закидываем по 1 человеку, а оставшихся в 1 
команду после чего комбинаторикой вычисляем сколько там будет комбинаций друзей по формуле (c - 1) + (c - 2) + ... + 1, 
где c - количество людей в 1 команде. Для вычисления минимума: распределяем участников поровну на все команды и берем 
с - количество человек в 1 команде. Далее оставшиеся люди пойдут как 1 к случайным командам. Вычисляем количество таких 
больших команд и количество малых. Далее по аналогии с минимумом вычисляем кол-во комбинаций друзей в 1 большой команде 
и в малой. Умножаем полученные результаты на количество соответсвующий команд складываем их.
### Task20
Идея в том, чтобы минимизировать первое число a чтобы оно было наименьшим делителем n и a != 1. Второе число b наименьший 
делитель числа n / a и b != 1 и b != a. После нахождения чисел из них вычисляем третье число c такое 
чтобы с != 1 и c != a и c != b иначе решения нет. Важный момент чтобы цикл при поиске был быстрее ограничение в while 
a < sqrt(n) && b < sqrt(n / a).
### Task21
Отсортировать массив после чего пройтись по нему и посчитать кол-во довольных людей, при этом недовольных людей 
не учитывать вообще как-будто мы их переместили в конец очереди (то есть их время обслуживания 
не прибавлять к времени ожидания для других людей в очереди).
### Task22
Проходиться по всем цифрам в числе и искать четные. Заранее заводим переменную со значением -1. При первой найденной 
запомнить ее позицию. Если найденное четная цифра меньше последней (с которой хотим поменять местами) выходим из цикла 
и меняем. Иначе продолжаем перебор дальше. По итогу если дошли до конца числа, меняем с первой найденной четной цифрой.
### Task23
Пока есть кол-во опытных(o) и новичков(y) больше нуля выполняем цикл, в котором по принципу кого больше o или y выбираем
тип команды.
### Task24
Идея в том что для того, чтобы операция swap была выгодна нужно чтобы два неправильных элемента стояли рядом при этом 
для них была актуальна данная операция, то есть ai и ai+1 были разными и не соответствовали 
своим bi и bi+1 соответственно. Во всех остальных случаях операция flip. Но сами операции не делаем только увеличиваем 
счетчик.
### Task26
С самого начала считаем сумму первых k элементов. Заводим переменные под минимальное значение суммы и для той, которую 
будем считать при каждой итерации. Далее итерируемся по массиву и сравниваем посчитанную сумму в этой итерации с 
минимальной. Если на итерации сумма меньше текущей минимальной суммы запоминаем указатель на элемент итерации и 
присваиваем переменной minCount новое значение. В конце выводим найденный элемент.
### Task27
Решил жадным алгоритмом нихуя там не дп. Сравниваешь два показателя заряда у кого меньше тот джойстик и заряжаешь.
### Task28
ВНИМАНИЕ!!! [Алгоритм нахождение подпоследовательности с большей суммой](https://e-maxx.ru/algo/maximum_average_segment).
Этот алгоритм необходим для решения данной задачи. Выучить! Пригодиться! Неважно какой отрезок для переворота мы выберем 
если там 0 то после переворота он нам даст +1 единицу. Если там 1, то после переворота -1 мы потеряем единицу из общего их числа. 
Значит мы можем перевести поступающий массив из 0/1 в массив с 1/-1 соответственно. После воспользоваться **алгоритмом 
нахождения последовательности с большей суммой**. Благодаря этому мы сожем узнать сколько максимум новых единиц сможем 
получить. Найденное значение прибавим к количеству единиц с самого начала, которые можно посчитать во время перевода 
массива или во время инпута. Ответ готов.
